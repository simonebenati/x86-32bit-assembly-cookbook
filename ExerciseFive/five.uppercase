# PURPOSE: THIS PROGRAM CONVERTS AN INPUT FILE TO AN OUTPUT FILE WITH ALL LETTERS CONVERTED TO UPPERCASE.

# PROCESSING: 1) OPEN THE INPUT FILE
#             2) OPEN THE OUTPUT FILE
#             3) WHILE WE'RE NOT AT THE END OF THE INPUT FILE:
#                A) READ A CHUNK OF DATA FROM THE INPUT FLEXIBLE
#                B) GO THROUGH EACH BYTE OF MEMORY, IF THE BYTE IS A LOWER-CASE LETTER, CONVERT IT TO UPPERCASE
#                C) WRITE THE MODIFIED CHUNK TO THE OUTPUT FLEXIBLE

.SECTION .DATA #NOT USED BUT WRITTEN FOR COMPLETENESS

#### CONSTANTS ####

.EQU OPEN, 5
.EQU WRITE, 4
.EQU READ, 3
.EQU CLOSE, 6
.EQU EXIT, 1

#OPTIONS FOR OPENING A FILE
#
#

.EQU O_RDONLY, 0
.EQU O_CREAT_WRONLY_TRUNC, 03101 #OPEN FILE OPTIONS FOR READ ONLY MODE
                                 #OPEN FILES OPTIONS:
                                 #CREAT - CREATE FILE IF IT DOESN'T EXISTS
                                 #WRONLY - WE WILL ONLY WRITE TO THIS FILE, NOT READ
                                 #TRUNC - DESTROY/OVERWRITE CURRENT FILE CONTENTS, IF ANY PREVIOUS EXISTS

#SYSTEM CALL INTERRUPT
.EQU LINUX_SYSCALL, 0X80

#END-OF-FILE RESULT STATUS
.EQU END_OF_FILE, 0 #THIS IS THE RETURN VALUE OF READ() WHICH MEANS WE'VE HIT THE END OF THE FILE


#### BUFFERS ####
.SECTION .BSS
#THIS IS WHERE THE DATA IS LOADED INTO FROM THE DATA FILE AND WRITTEN FROM INTO THE OUTPUT FILE.
#THIS SHOULD NEVER EXCEED 16000 BYTES FOR VARIOUS REASONS (32-BIT).
.EQU BUFFER_SIZE, 500
.LCOMM BUFFER_DATA, BUFFER_SIZE

#### PROGRAM CODE ####

.SECTION .TEXT

#STACK POSITIONS

.EQU ST_SIZE_RESERVE, 8
.EQU ST_FD_IN, 0
.EQU ST_FD_OUT, 4
.EQU ST_ARGC, 8 # POSITION OF THE NUMBER OF ARGUMENTS
.EQU ST_ARGV_0, 12 # POSITION FOR THE NAME OF THE PROGRAM
.EQU ST_ARGV_1, 16 # POSITION FOR THE INPUT OF THE FILENAME
.EQU ST_ARGV_2, 20 # POSITION FOR THE OUTPUT OF THE FILE NAME

.GLOBL _START
_START:
    ### INITIALIZE PROGRAM ###
    SUBL $ST_SIZE_RESERVE, %ESP #ALLOCATE SPACE FOR OUR POINTERS ON THE STACK
    MOVL %ESP, %EBP

    OPEN_FILES:
    OPEN_FD_IN:
        MOVL ST_ARGV_1(%EBP), %EBX #INPUT FILENAME INTO %EBX
        MOVL $O_RDONLY, %ECX #READ-ONLY FLAG
        MOVL $0666, %EDX #PERMISSIONS, ALTHOUGHT DOESN'T REALLY MATTER FOR READING
        MOVL $OPEN, %EAX #OPEN SYSCALL (SETTING EAX TO NUMBER 5 IN ORDER TO CALL APPROPRIATE SYSCALL)
        INT $LINUX_SYSCALL 

    STORE_FD_IN:
        MOVL %EAX, ST_FD_IN(%EBP) #LINUX SYSCALL RETURNS THE NUMBER OF THE FILE DESCRIPTOR GIVEN BY THE KERNEL. WE SAVE IT.

    OPEN_FD_OUT:
        ###OPEN OUTPUT FILE###
        MOVL ST_ARGV_2(%EBP), %EBX #OUTPUT FILENAME INTO %EBX
        MOVL $O_CREAT_WRONLY_TRUNC, %ECX #FLAGS FOR WRITING TO THE FILE
        MOVL $0666, %EDX #ASSIGNING PERMISSIONS TO THE NEW CREATED FILE, IF CREATED
        MOVL $OPEN, %EAX #OPEN THE FILE
        INT $LINUX_SYSCALL #CALL KERNEL LINUX

    STORE_FD_OUT:
        MOVL %EAX, ST_FD_OUT(%EBP)  #STORE THE RETURNED FILE DESCRIPTOR

    ### MAIN LOOP STARTS ###
    READ_LOOP_BEGIN:
    ### READ IN A BLOCK FROM THE INPUT FILE ###
        MOVL ST_FD_IN(%EBP), %EBX     #GET THE INPUT FILE DESCRIPTOR, (MEANING WHERE TO READ)
        MOVL $BUFFER_DATA, %ECX     #THE LOCATION TO READ INTO, PREALLOCATED IN .BSS SECTION
        MOVL $BUFFER_SIZE, %EDX     #THE SIZE OF THE BUFFER (ALLOCATED IN .BSS THESE NEED TO MATCH IN ORDER TO AVOID READING FROM VALUES IN OTHER ADDRESSES)
        MOVL $READ, %EAX        #PREPARE FOR SYSCALL WITH APPROPRIATE NUMBER
        INT $LINUX_SYSCALL
                            #SIZE OF BUFFER READ IS RETURNED IN %EAX
    ### EXIT IF WE REACHED THE END###
        CMPL $END_OF_FILE, %EAX
        JLE END_LOOP            #IF EAX IS SMALLER OR EQUAL TO 0 (END_OF_FILE) WE JUMP TO EXIT LOOP.

    CONTINUE_READ_LOOP:
    ### CONVERT BLOCK TO UPPER CASE###
        PUSHL $BUFFER_DATA        #CURRENT LOCATION OF THE BUFFER
        PUSHL %EAX                #CURRENT SIZE OF THE BUFFER
        CALL CONVERT_TO_UPPER
        POPL %EAX
        POPL %EBX
    ###WRITE THE BLOCK OUT TO THE OUTPUT FILE###
        MOVL ST_FD_OUT(%EBP), %EBX #FILE TO USE, WE USE FILE DESCRIPTOR TO REFERENCE IT
        MOVL $BUFFER_DATA, %ECX    #LOCATION OF THE BUFFER
        MOVL %EAX, %EDX            #SIZE OF THE BUFFER
        MOVL $WRITE, %EAX
        INT $LINUX_SYSCALL


    ###CONTINUE THE LOOP###
        JMP READ_LOOP_BEGIN

    END_LOOP:
    ### CLOSE THE FILES###
    #NOTE - WE DON'T NEED TO DO ERROR CHECK ON THESE, BECAUSE ERROR CONDITIONS DON'T MEAN ANYTHING SPECIAL HERE
        MOVL ST_FD_OUT(%EBP), %EBX
        MOVL $CLOSE, %EAX
        INT $LINUX_SYSCALL

        MOVL ST_FD_IN(%EBP), %EBX
        MOVL $CLOSE, %EAX
        INT $LINUX_SYSCALL

    ###EXIT###
    MOVL $0, %EBX
    MOVL $EXIT, %EAX
    INT $LINUX_SYSCALL

    ###FUNCTION CONVERT_TO_UPPER
    #
    # PURPOSE: THIS FUNCTION ACTUALLY DOES THE CONVERSION TO UPPER CASE FOR A BLOCK
    #
    # INPUT: THE FIRST PARAMTER IS THE LOCATION OF THE BLOCK OF MEMORY
    #        THE SECOND PARAMTER IS THE LENGTH OF THAT BUFFER
    #
    # OUTPUT: THIS FUNCTION OVERWRITES THE CURRENT BUFFER WITH THE UPPER-CASEIFIED VERSION
    #
    #
    # VARIABLES:
    #
    # %EAX - BEGINNING OF THE BUFFER
    # %EBX - LENGTH OF THE BUFFER
    # %EDI - CURRENT BUFFER OFFSET
    # %CL - CURRENT BYTE BEING EXAMINED (%CL IS THE FIRST BYTE OF %ECX)


    ###CONSTANTS###
    .EQU LOWERCASE_A, 'A'
    .EQU LOWERCASE_Z, 'Z'
    .EQU UPPER_CONVERSION, 'A' - 'A'

    ###STACK POSITIONS###
    .EQU ST_BUFFER_LEN, 8 #LENGTH OF BUFFER
    .EQU ST_BUFFER, 12 #ACTUAL BUFFER

    CONVERT_TO_UPPER:
        PUSHL %EBP
        MOVL %ESP, %EBP

    ###SET UP VARIABLES###
        MOVL ST_BUFFER(%EBP), %EAX
        MOVL ST_BUFFER_LEN(%EBP), %EBX
        MOVL $0, %EDI

    #IF A BUFFER WITH ZERO LENGTH WAS GIVEN US, JUST LEAVE
        CMPL $0, %EBX
        JE END_CONVERT_LOOP
    CONVERT_LOOP:
        #GET THE CURRENT BYTE
        MOVB (%EAX,%EDI,1), %CL

        #GO TO THE NEXT BYTE UNLESS IT'S BETTWEEN 'A' AND 'Z'
        CMPB $LOWERCASE_A, %CL
        JL NEXT_BYTE
        CMPB $LOWERCASE_Z, %CL
        JG NEXT_BYTE

        #OTHERWISE CONCVERT THE BYTE TO UPPERCASE
        ADDB $UPPER_CONVERSION, %CL
        #AND STORE IT BACK
        MOVB %CL, (%EAX,%EDI,1)
        
        NEXT_BYTE:
            INCL %EDI   #NEXT BYTE
            CMPL %EDI, %EBX #CONTINUE UNLESS WE'VE REACHED THE END
            JNE CONVERT_LOOP
        
        END_CONVERT_LOOP:
        #NO RETURN VALUE, JUST LEAVE
            MOVL %EBP, %ESP
            POPL %EBP
            RET


